<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Track Musical Player</title>
    <!-- Use Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use the Inter font for a clean look -->
    <style>
        body { font-family: "Inter", sans-serif; }
    </style>
    <!-- Import Tone.js library for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body class="bg-gray-900">
    <div id="app" class="flex flex-col items-center min-h-screen p-4 text-white">
        <div class="w-full max-w-4xl bg-gray-800 rounded-2xl shadow-xl p-8 space-y-8 border border-gray-700">
            <h1 class="text-4xl font-extrabold text-center text-indigo-400">
                Multi-Track Musical Player ðŸŽµ
            </h1>
            <p class="text-center text-gray-400">
                Create your own orchestra by adding multiple instrument tracks.
            </p>

            <!-- Playback Controls and Tempo -->
            <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-8">
                <div class="flex items-center space-x-2">
                    <label for="tempoInput" class="text-gray-400">Tempo (BPM):</label>
                    <input
                        type="number"
                        id="tempoInput"
                        value="100"
                        min="40"
                        max="240"
                        class="w-24 p-2 text-center bg-gray-700 text-gray-200 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors"
                    >
                </div>
                <button
                    id="playButton"
                    class="px-8 py-3 rounded-lg font-bold text-white shadow-lg transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 bg-indigo-500 hover:bg-indigo-600 focus:ring-indigo-500"
                >
                    Play All
                </button>
            </div>

            <!-- Tracks Container -->
            <div id="tracksContainer" class="space-y-6">
                <!-- Instrument tracks will be dynamically added here -->
            </div>

            <!-- Add Track Button -->
            <div class="flex justify-center mt-6">
                <button
                    id="addTrackButton"
                    class="px-6 py-2 rounded-lg font-bold text-gray-200 shadow-lg transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 bg-gray-700 hover:bg-gray-600 focus:ring-gray-500"
                >
                    + Add Track
                </button>
            </div>

            <!-- Status message area -->
            <div id="messageDisplay" class="text-center text-sm font-medium text-gray-400 mt-4">
                Click "Add Track" to begin composing!
            </div>
            <!-- Loading indicator for instruments -->
            <div id="loadingIndicator" class="text-center text-lg font-bold text-indigo-400 mt-4 hidden">
                Loading instruments... Please wait.
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            // === DOM Elements ===
            const tempoInput = document.getElementById('tempoInput');
            const playButton = document.getElementById('playButton');
            const tracksContainer = document.getElementById('tracksContainer');
            const addTrackButton = document.getElementById('addTrackButton');
            const messageDisplay = document.getElementById('messageDisplay');
            const loadingIndicator = document.getElementById('loadingIndicator');

            // === State Variables ===
            let isPlaying = false;
            let trackIndex = 0;
            const instruments = {}; // Stores Tone.js instruments keyed by their ID

            // Sampler presets for more realistic sounds
            const samplers = {};
            
            // Define all instruments to be loaded upfront
            const instrumentTypes = {
                'Synth': 'Synth',
                'Piano': 'Sampler',
                'Drums': 'Sampler',
                'Violin': 'Synth',
                'Cello': 'Synth', // Changed to Synth for reliability
                'Flute': 'Synth', // Changed to Synth for reliability
                'Organ': 'Sampler',
                'Gong': 'Sampler'
            };

            // Pre-defined melodies for each instrument
            const defaultMelodies = {
                'Synth': 'C4/4n, E4/4n, G4/4n, C5/4n',
                'Piano': 'C4/4n, G4/4n, A4/4n, G4/4n, F4/4n, E4/4n, D4/4n, C4/4n',
                'Drums': 'C1/8n, D#1/8n, F#1/8n, D#1/8n, C1/8n, D#1/8n, F#1/8n, D#1/8n',
                'Violin': 'C4/2n, G4/2n, C5/4n, G4/4n, E4/4n, C4/4n',
                'Cello': 'C2/2n, G2/2n, E2/2n, C2/2n',
                'Flute': 'C5/4n, D5/4n, E5/4n, F5/4n, G5/4n',
                'Organ': 'C3/4n, F3/4n, A3/4n, F3/4n, C3/4n',
                'Gong': 'C2/1m' // Special notation for the gong sound
            };

            // === Instrument Loading ===
            // This section pre-loads all Sampler instruments to prevent "buffer not loaded" errors.
            const createSamplers = async () => {
                loadingIndicator.classList.remove('hidden');
                playButton.disabled = true;
                addTrackButton.disabled = true;

                const promises = [];

                // Create and load all samplers
                samplers.Piano = new Tone.Sampler({
                    urls: {
                        "C3": "C3.mp3", "C4": "C4.mp3", "C5": "C5.mp3", "C6": "C6.mp3",
                    },
                    release: 1,
                    baseUrl: "https://tonejs.github.io/audio/salamander/",
                }).toDestination();
                promises.push(samplers.Piano.loaded);
                
                samplers.Drums = new Tone.Sampler({
                    urls: {
                        "C1": "https://tonejs.github.io/audio/drum-samples/acoustic-kit/kick.mp3",
                        "D#1": "https://tonejs.github.io/audio/drum-samples/acoustic-kit/snare.mp3",
                        "F#1": "https://tonejs.github.io/audio/drum-samples/acoustic-kit/hihat.mp3",
                    },
                    release: 1,
                }).toDestination();
                promises.push(samplers.Drums.loaded);
                
                // Cello and Flute changed to Synth, so no sampler loading is needed for them.
                
                samplers.Organ = new Tone.Sampler({
                    urls: {
                        "C3": "C3.mp3", "F3": "F3.mp3", "A3": "A3.mp3", "C4": "C4.mp3",
                    },
                    release: 1,
                    baseUrl: "https://tonejs.github.io/audio/salamander/",
                }).toDestination();
                promises.push(samplers.Organ.loaded);

                samplers.Gong = new Tone.Sampler({
                    urls: { "C2": "gong_1.mp3" },
                    release: 1,
                    baseUrl: "https://tonejs.github.io/audio/percussion/",
                }).toDestination();
                promises.push(samplers.Gong.loaded);

                await Promise.all(promises);

                loadingIndicator.classList.add('hidden');
                playButton.disabled = false;
                addTrackButton.disabled = false;
                messageDisplay.textContent = 'Instruments loaded. Click "Add Track" to begin composing!';
            };

            // Function to get a pre-loaded or new instrument instance
            const getInstrument = (type) => {
                if (instrumentTypes[type] === 'Sampler') {
                    // Return the pre-loaded sampler instance
                    return samplers[type];
                } else if (instrumentTypes[type] === 'Synth') {
                    // Create a new synth instance
                    return new Tone.PolySynth(Tone.Synth).toDestination();
                }
            };
            
            // === UI and State Functions ===
            const updateUI = () => {
                playButton.textContent = isPlaying ? 'Stop All' : 'Play All';
                playButton.classList.toggle('bg-red-500', isPlaying);
                playButton.classList.toggle('hover:bg-red-600', isPlaying);
                playButton.classList.toggle('focus:ring-red-500', isPlaying);
                playButton.classList.toggle('bg-indigo-500', !isPlaying);
                playButton.classList.toggle('hover:bg-indigo-600', !isPlaying);
                playButton.classList.toggle('focus:ring-indigo-500', !isPlaying);
            };

            // Function to add a new instrument track row to the DOM
            const addTrack = () => {
                const trackId = `track-${trackIndex++}`;
                const trackDiv = document.createElement('div');
                trackDiv.id = trackId;
                trackDiv.className = 'flex flex-col md:flex-row items-stretch md:items-center space-y-4 md:space-y-0 md:space-x-4 p-4 bg-gray-700 rounded-xl shadow-inner';

                const instrumentSelectorContainer = document.createElement('div');
                instrumentSelectorContainer.className = 'flex flex-col md:flex-row items-center space-y-2 md:space-y-0 md:space-x-2';

                const instrumentSelector = document.createElement('select');
                instrumentSelector.className = 'flex-none w-full md:w-32 p-2 bg-gray-600 text-gray-200 rounded-lg border border-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors';
                for (const type in instrumentTypes) {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    instrumentSelector.appendChild(option);
                }

                // Initial instrument setup
                instrumentSelector.value = 'Piano';
                const notesInput = document.createElement('textarea');
                notesInput.value = defaultMelodies['Piano'];
                instruments[trackId] = getInstrument(instrumentSelector.value);

                // Add experimental tag if necessary
                const experimentalTag = document.createElement('span');
                experimentalTag.textContent = 'Experimental';
                experimentalTag.className = 'px-2 py-1 bg-yellow-400 text-yellow-900 text-xs font-bold rounded-full';
                if (instrumentSelector.value === 'Synth' || instrumentSelector.value === 'Violin' || instrumentSelector.value === 'Cello' || instrumentSelector.value === 'Flute') {
                    instrumentSelectorContainer.appendChild(experimentalTag);
                }
                
                instrumentSelectorContainer.prepend(instrumentSelector);

                notesInput.className = 'flex-grow w-full p-2 text-sm bg-gray-600 text-gray-200 rounded-lg border border-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors resize-none';
                notesInput.rows = 2;
                notesInput.placeholder = 'e.g., C4/4n, Eb4/8n';
                
                // Add change listener to update notes and instrument
                instrumentSelector.addEventListener('change', (e) => {
                    const selectedType = e.target.value;
                    instruments[trackId] = getInstrument(selectedType);
                    notesInput.value = defaultMelodies[selectedType] || '';
                    
                    // Update experimental tag
                    const currentTag = instrumentSelectorContainer.querySelector('span');
                    if (selectedType === 'Synth' || selectedType === 'Violin' || selectedType === 'Cello' || selectedType === 'Flute') {
                        if (!currentTag) {
                            instrumentSelectorContainer.appendChild(experimentalTag);
                        }
                    } else {
                        if (currentTag) {
                            currentTag.remove();
                        }
                    }
                });

                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'flex-none flex justify-end space-x-2';

                const soloButton = document.createElement('button');
                soloButton.textContent = 'Solo';
                soloButton.className = 'px-4 py-2 rounded-lg font-bold text-sm transition-colors bg-orange-500 hover:bg-orange-600 text-white';
                soloButton.onclick = () => toggleSolo(trackId);

                const muteButton = document.createElement('button');
                muteButton.textContent = 'Mute';
                muteButton.className = 'px-4 py-2 rounded-lg font-bold text-sm transition-colors bg-red-500 hover:bg-red-600 text-white';
                muteButton.onclick = () => toggleMute(trackId);
                
                // Add a delete track button
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'px-4 py-2 rounded-lg font-bold text-sm transition-colors bg-gray-500 hover:bg-gray-600 text-white';
                deleteButton.onclick = () => deleteTrack(trackId);

                controlsDiv.appendChild(soloButton);
                controlsDiv.appendChild(muteButton);
                controlsDiv.appendChild(deleteButton);

                trackDiv.appendChild(instrumentSelectorContainer);
                trackDiv.appendChild(notesInput);
                trackDiv.appendChild(controlsDiv);

                tracksContainer.appendChild(trackDiv);
            };

            const deleteTrack = (trackId) => {
                const trackDiv = document.getElementById(trackId);
                if (trackDiv) {
                    tracksContainer.removeChild(trackDiv);
                    // Dispose of the instrument if it's a Synth to free up resources
                    if (instruments[trackId] instanceof Tone.PolySynth) {
                        instruments[trackId].dispose();
                    }
                    delete instruments[trackId];
                }
            };


            const toggleMute = (trackId) => {
                const instrument = instruments[trackId];
                const trackDiv = document.getElementById(trackId);
                const muteButton = trackDiv.querySelector('button.bg-red-500, button.bg-gray-400');

                if (instrument.volume.value === -Infinity) {
                    instrument.volume.value = 0; // Unmute
                    muteButton.textContent = 'Mute';
                    muteButton.classList.remove('bg-gray-400');
                    muteButton.classList.add('bg-red-500');
                } else {
                    instrument.volume.value = -Infinity; // Mute
                    muteButton.textContent = 'Unmute';
                    muteButton.classList.remove('bg-red-500');
                    muteButton.classList.add('bg-gray-400');
                }
            };

            const toggleSolo = (soloTrackId) => {
                const tracks = tracksContainer.children;
                const soloButton = document.getElementById(soloTrackId).querySelector('button.bg-orange-500, button.bg-yellow-500');
                const isAlreadySoloed = soloButton.classList.contains('bg-yellow-500');

                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    const trackId = track.id;
                    const instrument = instruments[trackId];
                    const currentSoloButton = track.querySelector('button.bg-orange-500, button.bg-yellow-500');
                    const currentMuteButton = track.querySelector('button.bg-red-500, button.bg-gray-400');

                    if (isAlreadySoloed) {
                        // Un-solo all tracks
                        instrument.volume.value = 0;
                        currentSoloButton.textContent = 'Solo';
                        currentSoloButton.classList.remove('bg-yellow-500');
                        currentSoloButton.classList.add('bg-orange-500');
                        currentMuteButton.textContent = 'Mute';
                        currentMuteButton.classList.remove('bg-gray-400');
                        currentMuteButton.classList.add('bg-red-500');
                    } else {
                        // Solo the selected track, mute others
                        if (trackId === soloTrackId) {
                            instrument.volume.value = 0;
                            currentSoloButton.textContent = 'Soloed';
                            currentSoloButton.classList.remove('bg-orange-500');
                            currentSoloButton.classList.add('bg-yellow-500');
                            currentMuteButton.textContent = 'Mute';
                            currentMuteButton.classList.remove('bg-gray-400');
                            currentMuteButton.classList.add('bg-red-500');
                        } else {
                            instrument.volume.value = -Infinity;
                            currentSoloButton.textContent = 'Solo';
                            currentSoloButton.classList.remove('bg-yellow-500');
                            currentSoloButton.classList.add('bg-orange-500');
                            currentMuteButton.textContent = 'Muted';
                            currentMuteButton.classList.remove('bg-red-500');
                            currentMuteButton.classList.add('bg-gray-400');
                        }
                    }
                }
            };

            // === Event Handlers ===
            const handlePlay = async () => {
                if (isPlaying) {
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    isPlaying = false;
                    messageDisplay.textContent = 'Stopped.';
                    updateUI();
                    return;
                }

                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }

                try {
                    isPlaying = true;
                    updateUI();
                    messageDisplay.textContent = 'Playing...';

                    Tone.Transport.stop();
                    Tone.Transport.cancel();

                    Tone.Transport.bpm.value = parseInt(tempoInput.value, 10);
                    let longestTrackDuration = 0;
                    
                    const tracks = tracksContainer.children;
                    if (tracks.length === 0) {
                        messageDisplay.textContent = 'Add a track to play!';
                        isPlaying = false;
                        updateUI();
                        return;
                    }

                    // Process each track
                    for (const track of tracks) {
                        const trackId = track.id;
                        const notesInput = track.querySelector('textarea');
                        const notes = notesInput.value.split(',').map(note => note.trim());
                        const instrument = instruments[trackId];
                        let currentTime = 0;

                        notes.forEach((noteString) => {
                            if (noteString) {
                                const parts = noteString.split('/');
                                const note = parts[0];
                                const duration = parts[1] || '4n';
                                
                                Tone.Transport.scheduleOnce(time => {
                                    instrument.triggerAttackRelease(note, duration, time);
                                }, currentTime);
                                
                                currentTime += Tone.Time(duration).toSeconds();
                            }
                        });

                        if (currentTime > longestTrackDuration) {
                            longestTrackDuration = currentTime;
                        }
                    }

                    Tone.Transport.scheduleOnce(() => {
                        isPlaying = false;
                        messageDisplay.textContent = 'Playback finished.';
                        updateUI();
                    }, longestTrackDuration);

                    Tone.Transport.start();

                } catch (error) {
                    console.error("Error playing notes:", error);
                    messageDisplay.textContent = `Error: Invalid notes format. Please check your input.`;
                    isPlaying = false;
                    updateUI();
                }
            };
            
            // Attach event listeners
            playButton.addEventListener('click', handlePlay);
            addTrackButton.addEventListener('click', addTrack);

            // Initial UI setup
            await createSamplers(); // Start pre-loading samplers
            addTrack(); // Add one track by default on page load
            updateUI();
        });
    </script>
</body>
</html>
